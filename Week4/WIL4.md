# 수업 내용
쿼리 파라미터를 통해 데이터를 전송할 때에는 어떤 메서드를 사용하나요?
**GET**

메시지의 body를 통해 데이터를 전송할 때에는 어떤 메서드를 사용하나요?
**POST, PUT, PATCH**

## HTTP 상태코드
### 1xx (informational)
클라이언트의 요청을 받았으며, 작업을 계속 진행 중에 있음을 나타냄. 정보 제공의 목적이 크다.
**대신 잘 사용하지 않음**

### 2xx (successful)
- 200 OK : 서버가 요청을 성공적으로 처리하였음을 나타냄
- 201 Created : 요청이 처리되어서 새로운 리소스가 생성되었음
- 202 (Accepted) : 요청은 접수되었지만, 처리가 완료되지 않았다.
- 204 (No Content) : 처리를 성공하였지만, 클라이언트에게 돌려줄 콘텐츠가 없다.(삭제)

### 3xx (Redirection)
클라이언트의 요청을 끝마치기 위해서, 웹 브라우저의 추가적인 동작이 필요한 상태임

- 300 Multiple Choices : 선택 항목이 여러 개 존재함
- 301 Moved Permanently : 지정한 리소스가 새로운 URL로 이동하였다.
- 302 Found : 다른 위치로 요청을 진행해라. 브라우저의 폼 요청을 POST 처리 후 리다이렉트
- 304 Not Midified : 마지막 요청 이후 페이지가 수정되지 않음
- 305 Use Proxy : 지정한 리소스에 엑세스하려면 프록시를 통해야 한다
- 307 Temporary Redirect : 임시로 리다이렉션 요청이 필요하다

### 4xx (Client Error)
- 400 Bad Request

    클라이언트의 잘못된 요청. 서버가 처리할 수 없는 상태
    - API 명세에 맞지 않게 요청을 보내거나, 파라미터 오타 실수
    - 요청 구문, 메시지 등등 오류 발생

    **응답코드의 중요성**
    400 상태코드를 내보내야 하는 오류를 실수로 500에러로 내보내게 된다면 같은 실수를 반복하여 수행하게 될 것이기 때문에 디버깅에 매우 중요하다!

- 401 Unauthorized
    클라이언트 요청이 해당 리소스에 대한 인증이 필요함

- 403 Forbidden
    서버에서 요청은 확인했지만, 리소스에 접근하는 것에 대한 승인을 거부함
    - 인증안 하였지만, 접근할 수 있는 권한이 없는 경우
    - ex. GDSC Hongik 학회원이 학회원 어드민 서비스 DB에 접근

- 404 Not Found
    요청한 리소스를 찾을 수 없음
    - 요청한 리소스가 서버에 존재하지 않을 때
    - 리스소가 서버에 존재하지만, 권한이 없어 리소스를 숨기고 싶을 때
### 5xx (Server Error)
- 500 Internal Server Error
    서버의 문제로 문제가 발생한 상황, 대부분 백엔드 에러

- 503 Service Unavailable
    서비스 이용 불가 상황
    - 서버가 일시적인 과부하가 걸리거나, 서버 서비스 점검 등으로 잠시 요청 처리 불가
    - Retry-After 헤더를 통해 언제부터 이용 가능한지 정보를 확인할 수 있음

## HTTP Header
### 표현 헤더 (Respresentation Header)
HTTP의 메시지 본문으로 전송된 리소스의 특정 '표현'을 설명하는 헤더이다.
- Content-Type : 표현 데이터의 형식으로 나타냄 (json이니, html이니?)
- Content-Encoding : 표현 데이터의 압축 방식 (gzip, deflate)
- Content-Language : 표현 데이터의 자연 언어 (ko, en)
- Content-Length : 표현 데이터의 길이 (byte 단위임)
### 요청 헤더(Request Header) - 협상 헤더
클라이언트가 이해 가능한 컨텐츠 타입이 무엇인지 알려준다. (선호 형식 안내)
- Accept: 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset: 클라이언트가 선호하는 방식의 문자 인코딩
- Accept-Encoding: 클라이언트가 선호하는 압축 인코딩 방식
- Accept-Language: 클라이언트가 선호하는 자연 언어

클라이언트가 제공한 선호 방식을 최고 우선순위에 두고 고려한다!

### 일반적인 요청 헤더 정보, 중요한 요청 헤더 정보
**일반적인 요청 헤더 정보**
Referer에서는 유저가 어떤 홈페이지를 통해 접속했는지 알 수 있다.
User-Agent에서 확인할 수 있는 것은 사용자가 사용하는 기기, 브라우저 등 사용자의 정보들이 들어있는데, 실무에서는 유저를 파악하는데 사용 가능하다. (당근에서 오류가 생겨 유저와 같은 조건에서 오류를 실행시켜서 디버깅 한다는 사례)

**중요한 요청 헤더 정보**
인터넷은 IP를 통해서만 통신하기 때문에, 어떤 포트로 들어가야 하는지 분명히 명시해야한다.
## 쿠키
**Set-Cookie**
    서버에서 클라이언트로 쿠키 전달
    (응답 헤더)

**Cookie**
    클라이언트가 서버에서 받은 쿠키를 저장
    HTTP 요청 시 서버로 전달

## 캐시
- 캐시의 유효 기간 까지는 네트워크 통신을 진행하지 않아도 된다.
- 네트워크 사용량을 줄여, 비용을 줄일 수 있다.
- 브라우저 로딩 속도가 매우 빨라진다.
- **빠른 사용자 경험을 제공할 수 있다!**


# 숙제
## 301, 303 요청을 하였을 때, 왜 httpstat.us 페이지의 메인으로 redirect될까?
수업시간에 301은 Moved Permanenetly로, 지정한 리소스가 새로운 URL로 이동했을 때 나타내는 리다이렉션이다. 301을 눌렀을 때, 새로운 URL이 httpstat.us의 메인 페이지이고, 눈치 챌 틈도 없이 빠르게 리다이렉션을 해주기 때문에 바로 페이지의 메인으로 redirect 되는 것이다.

303은 302와 기능이 같기 때문에 302와 동일하게 페이지의 메인을 redirect 하는 것이고, 301에서 얘기했던 것과 동일하게 매우 빠르게 redirect를 해주기 때문에 바로 메인페이지로 이동하는 것이다.

## 401 요청을 하였을 때, 네트워크 탭의 상태를 보고 어떻게 인증해야 하는지 www-Authenticate 헤더를 기반으로 설명해보자

서버가 클라이언트에게 401 요청을 통해 인증을 요구한다. 이때 **www-Authenticate : Basic realm = ""** 식으로 헤더가 표시된다.
클라이언트는 따옴표 안의 정보를 보고 알맞은 비밀번호를 사용해야 한다.

**Authorization**은 클라이언트에서 서버로 응답 값을 담는 헤더이며, 사용자에게 받은 ID/PW를 base-64 인코딩을 한 정보이다.

## Google에 "Hello"를 입력하야 결과물을 보고, 네트워크 요청 탭에서 캐시 관련 정보가 어디에 저장되어 있는지 분석해 보자.
잘 찾은건지 모르겠지만, 캐시의 정보는 응답 헤더와 요청 헤더에 **Cache-Control**이 표현되어있다.
Cache-Control에는 **no-cache, no-store, max-age=??, must-revalidate, immutable** 등이 있었다.

### no-store
아무것도 캐싱하지 않으려면 no-store을 사용한다.
### no-cache
브라우저가 캐시를 참조하지 않고, 서버에 대해 컨텐츠 유효성을 검사하도록 지시한다. 즉 서버에서 캐시 저장여부를 물어본다.
### must-revalidate
만료된 캐시만 서버에 확인을 받는다.
### public, private
* public: 컨텐츠를 공개한다. 브라우저외에 중개 서버에 저장 허용.
* private: 특정 사용자 환경(오직 브라우저)에만 캐시 저장 허용.
### max-age
캐시 유효기간을 설정한다. 초(second)단위로 값을 할당한다.
### s-maxage
공유캐시에서만 동작하며, max-age, expires 헤더를 재정의한다.
